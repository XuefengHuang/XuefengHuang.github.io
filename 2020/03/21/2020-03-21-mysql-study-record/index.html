<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Xuefeng"><title>Mysql学习笔记 · xuefenghuang.github.io</title><meta name="description" content="建索引的几大原则（https://tech.meituan.com/mysql-index.html）（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; "><meta name="keywords" content="Golang, Redis, Mysql, Kafka"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title style="text-transform:none;"><a href="/">Xuefeng</a></h3><div class="description"><p>stay hungry stay foolish</p></div></div></div><ul class="social-links"><li><a href="http://github.com/XuefengHuang"><i class="fa fa-github"></i></a></li><li><a href="mailto:huangxuefengcn@gmail.com"><i class="fa fa-envelope"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Mysql学习笔记</a></h3></div><div class="post-content"><h3 id="建索引的几大原则（https-tech-meituan-com-mysql-index-html）"><a href="#建索引的几大原则（https-tech-meituan-com-mysql-index-html）" class="headerlink" title="建索引的几大原则（https://tech.meituan.com/mysql-index.html）"></a>建索引的几大原则（<a href="https://tech.meituan.com/mysql-index.html）" target="_blank" rel="noopener">https://tech.meituan.com/mysql-index.html）</a></h3><p>（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>（2）=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式<br>（3）尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录<br>（4）索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);<br>（5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
<h3 id="MySQL索引方法？索引的优化？"><a href="#MySQL索引方法？索引的优化？" class="headerlink" title="MySQL索引方法？索引的优化？"></a>MySQL索引方法？索引的优化？</h3><p>索引是B+树实现的，类似字典的目录提高查找速度。<br>B+树搜索效率比较平均，擅长范围查询。hash索引擅长等值查询。</p>
<h3 id="MySQL的联合索引-又称多列索引-是什么？生效的条件？"><a href="#MySQL的联合索引-又称多列索引-是什么？生效的条件？" class="headerlink" title="MySQL的联合索引(又称多列索引)是什么？生效的条件？"></a>MySQL的联合索引(又称多列索引)是什么？生效的条件？</h3><p>组合索引的生效原则是  从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用<br>B+树存储的是健值对。比如联合索引是a,b，存储的是（a,b）排序结果。<br><img src="/images/union_index.png" alt="Image of Example1"></p>
<h3 id="InnoDB与MyISAM区别？"><a href="#InnoDB与MyISAM区别？" class="headerlink" title="InnoDB与MyISAM区别？"></a>InnoDB与MyISAM区别？</h3><p>（1）事务处理：<br>MyISAM是非事务安全型的，而InnoDB是事务安全型的（支持事务处理等高级处理）；通过REDO日志和UNDO日志实现.<br>（2）锁机制不同：<br>MyISAM是表级锁，而InnoDB是行级锁；<br>（3）select ,update ,insert ,delete 操作：<br>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表<br>（4）查询表的行数不同：<br>MyISAM：select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含   where条件时，两种表的操作是一样的<br>InnoDB ： InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行<br>（5）MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶结点data域保存了完整的数据记录。<br>（6）哈希索引也不支持多列联合索引的最左匹配规则</p>
<h3 id="联合索引好处"><a href="#联合索引好处" class="headerlink" title="联合索引好处"></a>联合索引好处</h3><p>（1）”一个顶三个”。建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！<br>（2）覆盖索引。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。</p>
<h3 id="数据库四种隔离级别"><a href="#数据库四种隔离级别" class="headerlink" title="数据库四种隔离级别"></a>数据库四种隔离级别</h3><p>（1）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<br>（2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。Innodb默认。<br>（3）Read committed (读已提交)：可避免脏读的发生。<br>（4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
<ul>
<li><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
</li>
<li><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
</li>
<li><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
</li>
<li><p>事务的隔离性是通过数据库锁的机制实现的，持久性通过 Redo Log（重做日志）来实现，原子性和一致性通过 Undo Log 来实现。</p>
</li>
</ul>
<h3 id="Mysql主从同步原理"><a href="#Mysql主从同步原理" class="headerlink" title="Mysql主从同步原理"></a>Mysql主从同步原理</h3><ul>
<li>从库生成两个线程，一个I/O线程，一个SQL线程；</li>
<li>i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；<br>主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；</li>
<li>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</li>
</ul>
<h3 id="Inodb行锁的3种算法"><a href="#Inodb行锁的3种算法" class="headerlink" title="Inodb行锁的3种算法"></a>Inodb行锁的3种算法</h3><p>(1) record lock: 单个行记录上的锁<br>(2) gap lock: 间隙锁，锁定一个范围，但不包含记录本身<br>(3) next-key lock: gap lock+record lock，锁定一个范围，并且锁定记录本身. Innodb默认解决不可重复度问题。</p>
<h3 id="集群分布式："><a href="#集群分布式：" class="headerlink" title="集群分布式："></a>集群分布式：</h3><ul>
<li>组复制：<a href="https://www.cnblogs.com/kevingrace/p/10260685.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/10260685.html</a></li>
<li>分布式事务：<a href="https://developer.51cto.com/art/201808/581174.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/201808/581174.htm</a></li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-21</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://xuefenghuang.github.io/2020/03/21/2020-03-21-mysql-study-record/,xuefenghuang.github.io,Mysql学习笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/03/21/2020-03-21-distributelock/" title="分布式系统学习笔记">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>